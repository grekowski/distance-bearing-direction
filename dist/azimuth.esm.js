const R=6371009;function deg2rad(t){return t*(Math.PI/180)}function rad2deg(t){return t*(180/Math.PI)}function calculateAzimuthRhumbLine(t,r,e,a){if(t===e&&r===a)return 0;const n=deg2rad(t),i=deg2rad(e);let o=deg2rad(a-r);const s=Math.log(Math.tan(Math.PI/4+i/2)/Math.tan(Math.PI/4+n/2));Math.abs(o)>Math.PI&&(o=o>0?-(2*Math.PI-o):2*Math.PI+o);return(rad2deg(Math.atan2(o,s))+360)%360}function calculateAzimuthGreatCircle(t,r,e,a){const n=deg2rad(t),i=deg2rad(e),o=deg2rad(a-r),s=Math.sin(o)*Math.cos(i),u=Math.cos(n)*Math.sin(i)-Math.sin(n)*Math.cos(i)*Math.cos(o);return(rad2deg(Math.atan2(s,u))+360)%360}function convertToCompassDirection(t,r){if(isNaN(t)||isNaN(r))throw new Error("Parameter is not a number!");if(t<0||t>360)throw new Error("Parameter outside of range!");if(r<1||r>3)throw new Error("Parameter outside of range!");const e=["N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSW","SW","WSW","W","WNW","NW","NNW"];let a=4;2==r&&(a=8),3==r&&(a=16);const n=360/a,i=e.length/a;let o=Math.round(t/n)*i;return o>=e.length&&(o=0),e[o]}function getDistanceGreatCircle(t,r,e,a){if(t===e&&r===a)return 0;const n=deg2rad(t),i=deg2rad(e),o=deg2rad(t-e),s=deg2rad(r-a),u=Math.sin(o/2)*Math.sin(o/2)+Math.cos(n)*Math.cos(i)*Math.sin(s/2)*Math.sin(s/2),h=2*Math.atan2(Math.sqrt(u),Math.sqrt(1-u));return R*h}function getDistanceRhumbLine(t,r,e,a){if(t===e&&r===a)return 0;const n=deg2rad(t),i=deg2rad(e),o=deg2rad(t-e);let s=deg2rad(r-a);const u=Math.log(Math.tan(Math.PI/4+i/2)/Math.tan(Math.PI/4+n/2)),h=Math.abs(u)>1e-11?o/u:Math.cos(n);Math.abs(s)>Math.PI&&(s=s>0?-(2*Math.PI-s):2*Math.PI+s);return Math.sqrt(o*o+h*h*s*s)*R}function unitsConverter(t,r="m"){if("m"===r)return t;switch(r){case"km":return.001*t;case"ft":return 3.28084*t;case"yd":return 1.0936*t;case"mi":return 621371e-9*t;case"nm":return 539957e-9*t;default:return t}}Number.prototype.round=function(t=0){const r=new Number(this.valueOf());return+(Math.round(r+"e+"+t)+"e-"+t)};const azimuth=function(t,r,{units:e="m",distancePrecision:a=0,formula:n="great-circle",azimuthPrecision:i=0,directionPrecision:o=2}={}){if([t,r].forEach((r=>{if(!r.hasOwnProperty("lat")||!r.hasOwnProperty("lng"))throw new Error("Latitude/Longitude property missing!");if(isNaN(r.lat)||isNaN(r.lng))throw new Error("Latitude/Longitude property must be a number!");if(Math.abs(r.lat)>90||Math.abs(t.lng)>180)throw new Error("Latitude/Longitude property exceeding maximal value!")})),!["m","km","ft","yd","mi","nm"].includes(e))throw new Error("Units parameter type not supported!");if(isNaN(a)||isNaN(i)||a>15||i>15)throw new Error("Precision parameter is not a number or exceeds it's maximum value of 15!");if(!["great-circle","rhumb-line"].includes(n))throw new Error("Calculation formula type parameter not supported!");if(![0,1,2,3,"0","1","2","3"].includes(o))throw new Error("Compass precision parameter not supported!");let s={};const u=unitsConverter("rhumb-line"===n?getDistanceRhumbLine(t.lat,t.lng,r.lat,r.lng):getDistanceGreatCircle(t.lat,t.lng,r.lat,r.lng),e).round(a);s.distance=u,s.units=e;const h=0===u?"":("rhumb-line"===n?calculateAzimuthRhumbLine(t.lat,t.lng,r.lat,r.lng):calculateAzimuthGreatCircle(t.lat,t.lng,r.lat,r.lng)).round(i);return s.azimuth=h,s.formula=n,0!=o&&(s.direction=0===u?"":convertToCompassDirection(h,o)),s};export default azimuth;