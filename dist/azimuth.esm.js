const R=6371009;function deg2rad(t){return t*(Math.PI/180)}function degrees(t){return t*(180/Math.PI)}function getBearingRhumbLine(t,e,r,a){if(t===r&&e===a)return 0;const n=deg2rad(t),i=deg2rad(r);let o=deg2rad(a-e);const s=Math.log(Math.tan(Math.PI/4+i/2)/Math.tan(Math.PI/4+n/2));Math.abs(o)>Math.PI&&(o=o>0?-(2*Math.PI-o):2*Math.PI+o);return(degrees(Math.atan2(o,s))+360)%360}function getBearingGreatCircle(t,e,r,a){const n=deg2rad(t),i=deg2rad(r),o=deg2rad(a-e),s=Math.sin(o)*Math.cos(i),u=Math.cos(n)*Math.sin(i)-Math.sin(n)*Math.cos(i)*Math.cos(o);return(degrees(Math.atan2(s,u))+360)%360}function getCompassDirection(t,e){if(isNaN(t)||isNaN(e))throw new Error("Parameter is not a number!");if(t<0||t>360)throw new Error("Parameter outside of range!");if(e<1||e>3)throw new Error("Parameter outside of range!");const r=["N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSW","SW","WSW","W","WNW","NW","NNW"];let a=4;2===e&&(a=8),3===e&&(a=16);let n=360/a,i=r.length/a,o=Math.round(t/n)*i;return o>=r.length&&(o=0),r[o]}function getDistanceGreatCircle(t,e,r,a){if(t===r&&e===a)return 0;const n=deg2rad(t),i=deg2rad(r),o=deg2rad(t-r),s=deg2rad(e-a),u=Math.sin(o/2)*Math.sin(o/2)+Math.cos(n)*Math.cos(i)*Math.sin(s/2)*Math.sin(s/2),h=2*Math.atan2(Math.sqrt(u),Math.sqrt(1-u));return R*h}function getDistanceRhumbLine(t,e,r,a){if(t===r&&e===a)return 0;const n=deg2rad(t),i=deg2rad(r),o=deg2rad(t-r);let s=deg2rad(e-a);const u=Math.log(Math.tan(Math.PI/4+i/2)/Math.tan(Math.PI/4+n/2)),h=Math.abs(u)>1e-11?o/u:Math.cos(n);Math.abs(s)>Math.PI&&(s=s>0?-(2*Math.PI-s):2*Math.PI+s);return Math.sqrt(o*o+h*h*s*s)*R}function metersConverter(t,e="m"){if("m"===e)return t;switch(e){case"km":return.001*t;case"ft":return 3.28084*t;case"yd":return 1.0936*t;case"mi":return 621371e-9*t;case"nm":return 539957e-9*t;default:return t}}Number.prototype.round=function(t=0){const e=new Number(this.valueOf());return+(Math.round(e+"e+"+t)+"e-"+t)};const azimuth=function(t,e,r,a,{units:n="m",distancePrecision:i=0,formula:o="great-circle",bearingPrecision:s=0,directionPrecision:u=2}={}){if(isNaN(t)||isNaN(r)||isNaN(e)||isNaN(a)||isNaN(s)||isNaN(u))throw new Error("Latitude/Longitude parameter is not a number!");if(Math.abs(t)>90||Math.abs(r)>90||Math.abs(e)>180||Math.abs(a)>180)throw new Error("Latitude/Longitude parameter exceeding maximal value!");if(isNaN(i)||isNaN(s)||i>15||s>15)throw new Error("Precision parameter is not a number or exceeds it's maximum value of 15!");if(!["m","km","ft","yd","mi","nm"].includes(n))throw new Error("Units parameter type not supported!");if(!["great-circle","rhumb-line"].includes(o))throw new Error("Calculation formula type parameter not supported!");let h={};const c=metersConverter("rhumb-line"===o?getDistanceRhumbLine(t,e,r,a):getDistanceGreatCircle(t,e,r,a),n).round(i);h.distance=c,h.units=n;const d=0===c?"":("rhumb-line"===o?getBearingRhumbLine(t,e,r,a):getBearingGreatCircle(t,e,r,a)).round(s);return h.bearing=d,h.formula=o,0!==u&&(h.direction=0===c?"":getCompassDirection(d,u)),h};export default azimuth;